# 网络协议

[TOC]

## 1. 基本概念

### 1.1 网络互联模型

`OSI`参考模型

```mermaid
graph TD
应用层 --> 表示层 --> 会话层 --> 运输层 --> 网络层 --> 数据链路层 --> 物理层
```

`TCP/IP`协议

```mermaid
graph TD
应用层 --> 运输层 --> 网际层 --> 网络接口层
```

学习研究

```mermaid
graph TD
应用层 --> 运输层 --> 网际层 --> 数据链路层 --> 物理层
```

### 1.2 通信基础

#### 1.2.1 通信过程

1. 获取对方的`IP`地址和对应的`MAC`地址
2. 如果此时发送方不知道目的地址的`MAC`，会使用`ARP`协议在同一个网段进行广播，获取目的地址的`MAC`地址
3. 根据`MAC`地址(网卡地址)，输送数据到网卡，被网卡接受
4. 如果对方发现`MAC`地址不是自己的则会丢弃

#### 1.2.2 计算机的连接方式

1. 同轴电缆

   ![image-20210210124220690](网络协议.assets/image-20210210124220690.png)这种方式为**半双工通信**同一时间只允许一个用户进行发送，容易冲突

   因为数据会从发送方发给每一个用户，所以不安全

2. 集线器

   ![image-20210210131607414](网络协议.assets/image-20210210131607414.png)

   半双工通信，容易冲突

   一个集线器能够连接的设备是有上限的，可以采用集线器连接集线器的方式进行连接

   数据也会从发送方发给每一个用户，所以也不安全

3. 网桥

   ![image-20210210133537667](网络协议.assets/image-20210210133537667.png)

   通过自学习得知每个接口的`MAC`地址，从而起到隔绝冲突域的作用

   如上图在每一次的`ARP`数据传送中，网桥就可以记录下`ip`对应的`MAC`地址，在数据经过网桥时可以比对`MAC`地址，从而实现隔绝的效果 

4. 交换机

   ![image-20210210140623590](网络协议.assets/image-20210210140623590.png)

   相当于接口更多的网桥，能够实现**全双工通信**

   第一次发送数据时`ARP`依旧会采用广播的方式，但是此时的交换机会记录下每个接口对应的`MAC`地址

5. 路由器

   以上的四种方式，所有的设备必须处在同一个网段，即处在同一个广播域

   路由器则可以在不同网段之间转发数据，路由器连接的设备一定要处于**不同**的网段

   ![image-20210210195940917](网络协议.assets/image-20210210195940917.png)

   **发送数据的步骤**

   在主机发送数据之前，首先会判断目标主机的`IP`地址跟它是否在同一个网段

   判断是否在同一个网段的方法是拿自己的子网掩码和对方的`IP`地址进行`&`运算

   在同一个网段发送`ARP`广播，通过交换机\集线器传递数据，不在同一个网段通过路由器转发数据
   
   通过路由器转发数据就需要网关（Gateway），网关一般设置为每一个网段的第一个`ip`地址，不在同一个网段互相传数据，会将数据传送给自己的网关（一个路由器起内包含连接在路由器上的所有网关），经由对方的网关传送给对方

## 2. MAC和IP

### 2.1 MAC地址

每一个网卡都有一个6字节的`MAC`地址（Media Access Control Address）

`MAC`地址全球唯一，固化在了网卡的`ROW`中，由`IEEE802`标准规定

前三个字节`OUI`（Organizationally Unique Identifier）是网卡厂家，后三个字节由厂商自行分配

| 组织唯一标识 | 网络接口标识 |
| ------------ | ------------ |
| 40-55-82     | 0A-8C-6D     |

当`MAC`地址为`FF-FF-FF-FF-FF-FF`时代表广播地址

**arp**

当发送方不知道对方主机的`MAC`地址时，可以通过发送`ARP`广播获取对方的`MAC`地址，获取成功后，发送方会缓存`IP`地址、`MAC`地址的映射信息，俗称`ARP`缓存

通过`arp`广播获取的`MAC`地址，属于动态`dynamic`缓存，存储时间比较短（默认是2分钟），过期了自动删除

查看缓存

```shell
arp -a
```

### 2.2 IP地址

#### 2.2.1 简介

`IP`地址（Internet Protocol Address）：互联网上的每一个主机都有一个`IP`地址，最初为`IPV4`版本，`32bit`（4字节），2019年11月25日，全球的`Ip`地址已经耗尽，目前正在推广`IPv6`

| 第一部分  | 第二部分  | 第三部分  | 第四部分  |
| --------- | --------- | --------- | --------- |
| 1100 0000 | 1010 1000 | 0000 0001 | 0000 1010 |
| 192       | 168       | 1         | 10        |

**功能**

假设

```
IP地址：192.168.1.10
子网掩码：255.255.255.0
```

| 网络ID                        | 主机ID    |
| ----------------------------- | --------- |
| 1100 0000 1010 1000 0000 0001 | 0000 1010 |
| 192.168.1                     | 10        |

`IP`地址由2部分组成：网络标识（网络ID）、主机标识（主机ID），同一个网段的计算机，网络ID相同

通过子网掩码（`subnet mask`）可以计算出网络ID：**子网掩码&IP地址**

如果主机ID位为全`0`代表网段地址，如上的网段地址为

```
192.168.1.0
```

如果主机ID位为全`1`代表给这个网段的所有主机发送消息，即广播地址，如上的广播地址为

```
192.168.1.255
```

#### 2.2.2 IP地址的分类

- `A`类地址：默认子网掩码是`255.0.0.0`

  | 8bit         | 24bit  |
  | ------------ | ------ |
  | 网络ID 0开头 | 主机ID |

  网络ID的取值范围为`0~127`，`0`不能用，`127`作为保留网段，其中`127.0.0.1`是本地环回地址`Loopback`，代表本机地址，所以`A`类地址网络ID的实际取值范围为`1~126`

  每个`A`类网络能容纳的最大主机数是：`256 * 256 * 256 - 2 = 1677 7214`

- `B`类地址：默认子网掩码是`255.255.0.0`

  | 16bit         | 16bit    |
  | ------------- | -------- |
  | 网络ID 10开头 | 主机标识 |

  第一个字节的取值范围为`128~191`，每个`B`类网络能够容纳的最大主机数是：`256 * 256 - 2 = 6 5534`

- `C`类地址：默认子网掩码是`255.255.255.0`

  | 24bit          | 8bit   |
  | -------------- | ------ |
  | 网络ID 110开头 | 主机ID |

  第一个字节的取值为`192~223`，每个`C`类网络能够容纳的最大主机数是：`256 - 2 = 254`

- `D`类地址：以`1110`开头，没有子网掩码，用于多播地址

  第一个字节的取值范围：`224~239`

- `E`类地址：以`1111`开头，保留为今后使用

  第一个字节的取值范围：`240~255`

只有`A`、`B`、`C`类地址才能分配给主机

#### 2.2.3 公网IP、私网IP

`IP`地址分为：公网`IP`和私网`IP`

**公网IP**

`Internet`上的路由器中只有到达公网的路由表，没有到达私网的路由表

公网`IP`由因特网信息中心`Internet Network Information Center, Inter NIC`统一分配和管理

`ISP`需要想`Inter NIC`申请公网`IP`

**私网IP**

主要用于局域网。下面是保留的私网网段

| 类型 | 范围                            | 网段数量 |
| ---- | ------------------------------- | -------- |
| A类  | 10.0.0.0/8                      | 1        |
| B类  | 172.16.0.0/16~172.31.0.0/16     | 16       |
| C类  | 192.168.0.0/24~192.168.255.0/24 | 256      |

### 2.3 子网掩码

#### 2.3.1 子网掩码的表示方法

`CIDR`（Classless Inter-Domain Routing）：无类别域间路由表示法

`192.168.1.100/24`，代表子网掩码有24个1，也就是`255.255.255.0`

`123.210.100.200/16`，代表子网掩码有16个1，也就是`255.255.0.0`

#### 2.3.2 子网划分

**为什么要进行子网划分？**

如果让**200**台主机在同一个网段内，就可以分配一个`C`类网段，比如`192.168.1.0/24`，总共`254`个可用的`IP`地址：`192.168.1.1`~`192.168.1.254`，多出`54`个空闲`ip`地址，这种情况并不算浪费资源。

如果让**500**台主机在同一个网段内，那就分配一个`B`类网段，比如`191.100.0.0/16`，总共`65534`个可用`IP`地址：`191.100.0.1`~`191.100.255.254`，多出`65034`个空闲的`IP`地址，这种情况属于极大的浪费资源。

为了解决资源浪费的问题，提出了子网划分的概念。

**子网划分**

假设对一个`C`类网段进行子网划分

```
192.168.0.0/24
```

借用主机位作子网位，划分出多个子网

划分方式:

1. 等长子网划分：将一个网段等分为多个子网，每个子网的可用`IP`地址数量是一样的

   | A子网    | 1100 0000 | 1010 1000 | 0000 0000 | 0    | 000 0000 |
   | -------- | --------- | --------- | --------- | ---- | -------- |
   | B子网    | 1100 0000 | 1010 1000 | 0000 0000 | 1    | 000 0000 |
   | 子网掩码 | 255 | 255 | 255 | 128 |          |

   将主机的一位拿出来当做子网掩码的一部分，就会变成两个不同的网段

   ```
   A子网：192.168.0.0/25
   B子网：192.168.0.128/25
   两个网段的子网掩码都是：255.255.255.128
   ```

   对于A子网的取值范围应该是：`192.168.0.1`~`192.168.0.126`

   对于B子网的取值范围应该是：`192.168.0.129`~`192.168.0.254`

   ![image-20210211113554545](网络协议.assets/image-20210211113554545.png)

2. 变长子网划分：每个子网的可用`IP`地址数量可以是不一样的

   ![image-20210211115326654](网络协议.assets/image-20210211115326654.png)

   如果一个子网地址块的长度是原网段的`(1/2)^n`，那么子网的子网掩码，就是在原网段的子网掩码的基础上增加n个1，不等长的子网他们的子网掩码也不同。

   **各个网段的划分情况**

   | 网段 | 子网掩码           | 网络取值范围                |
   | ---- | ------------------ | --------------------------- |
   | A    | 255.255.255.224/27 | 192.168.0.33~192.168.0.62   |
   | B    | 255.255.255.192/26 | 192.168.0.65~192.168.0.126  |
   | C    | 255.255.255.128/25 | 192.168.0.129~192.168.0.254 |
   | D    | 255.255.255.252/30 | 192.168.0.1~192.168.0.2     |
   | E    | 255.255.255.252/30 | 192.168.0.5~192.168.0.6     |

#### 2.3.3 超网

跟子网反过来，它是将多个**连续**的网段合并成一个更大的网段

需求：原本有**200**台计算机使用`192.168.0.0/24`网段，现在希望增加**200**台设备到同一个网段

解决方法：200台在`192.168.0.0/24`网段，200台在`192.168.1.0/24`网段，并将两个网段合并为同一个网段：`192.168.0.0/23`

| 192.168.0.0 | 1100 0000 | 1010 1000 | 0000 0000 | 0000 0000 |
| ----------- | --------- | --------- | --------- | --------- |
| 192.168.1.0 | 1100 0000 | 1010 1000 | 0000 0001 | 0000 0000 |
| 子网掩码    | 1111 1111 | 1111 1111 | 1111 1110 | 0000 0000 |
| 子网掩码    | 255       | 255       | 254       | 0         |

它们的网段为`192.168.0.0/23`广播地址为`192.168.1.255`

![image-20210211134315790](网络协议.assets/image-20210211134315790.png)

**合并规律**

假设n是2的K（k>=1）次幂，如果第一个网段的网络号能被n整除，那么由它开始连续的n个网段，能够通过左移k为子网掩码进行合并

比如：

- 第一个网段的网络号以二进制0结尾，那么由它开始连续的2个网段，能够通过左移1位子网掩码进行合并
- 第一个网段的网络号以二进制00结尾，那么由它开始连续的4个网段，能够通过左移2位子网掩码进行合并
- 第一个网段的网络号以二进制000结尾，那么由它开始连续的8个网段，能够通过左移2位子网掩码进行合并

### 2.4 IPv6

`IPv6(Internet Protocol version 6)`，网际协议第六版，用它来取代`IPv4`主要是为了解决`IPv4`地址枯竭的问题，同时它也在其他方面对于`IPv4`有许多改进

然而长期以来在互联网流量中仍然占主要地位，`IPv6`的使用增长缓慢

`IPv6`采用128位的地址，每16bit一组，共8组

每组以冒号":"隔开，每组以4位是十六进制方式表示

```
2001:0db8:3c4d:0015:0000:0000:1a2f:1a2b
```

`::1`本地环回地址

## 3. 路由

### 3.1 路由寻址

在不同网段之间转发数据，需要有路由器的支持。默认情况下，路由器只知道跟它直连的网段，非直连的网段都需要通过静态路由、动态路由告诉它

静态路由：管理员手动添加路由信息，适用于小规模网络

动态路由：路由器通过路由选择协议（比如`RIP`、`OSPF`）自动获取路由信息，使用于大规模网络

**以下为静态路由**

![image-20210211152330909](网络协议.assets/image-20210211152330909.png)

每一个路由器内都有一张路由表，记录不同路由器之间不同网段的通信路径

假设`192.168.1.10/24`和`193.169.2.10/24`要通信，两个路由器需要使用同一个网段的`IP`进行通信

**路由器0**

![image-20210211152559644](网络协议.assets/image-20210211152559644.png)

**路由器1**

![image-20210211152743450](网络协议.assets/image-20210211152743450.png)

设置更高层次的模糊匹配

![image-20210211155847143](网络协议.assets/image-20210211155847143.png)

也可以设置默认匹配

![image-20210211155417578](网络协议.assets/image-20210211155417578.png)

### 3.2 数据包的传输过程

![image-20210211172036400](网络协议.assets/image-20210211172036400.png)

主机`192.168.1.10/24`要发送消息给`192.168.3.10/24`，第一步，并不是获取对方的`MAC`地址，而是获取网关的`MAC`地址，在传送过程中，`IP`地址不会改变，而`MAC`地址会不断变更

### 3.3 网络、互联网、因特网

![image-20210211172349063](网络协议.assets/image-20210211172349063.png)

![image-20210211172415233](网络协议.assets/image-20210211172415233.png)

世界上最大的互联网就是**因特网**`Internet`，将全世界的互联网连接一起

`ISP`（Internet Service Provider）`Internet`服务提供商，比如移动、电信、网通、铁通等

### 3.4 网络分类

按照网络的范围进行分类，可以分为：局域网、城域网、广域网等

**局域网**

1. `Local Area Network`，LAN，一般为几百米到十几公里内的计算机所构成的计算机网络，常用于公司、家庭、学校、医院、机关、一栋大楼等

2. 局域网中使用最广泛的网络技术叫：以太网`Ethernet`

3. 在电脑、手机上经常见到的一个英文`WLAN`（Wireless LAN），意思是无线局域网

**城域网**

`Metropolitan Area Network`，MAN，一般范围是数十公里到数百公里，可以覆盖一个城市

**广域网**

`Wide Area Network`，WAN，一般范围是几百公里到几千公里，可以覆盖一个国家。通常都需要租用`ISP`的线路

### 3.5 常见的几种接口

1. `FastEthernet`

   快速以太网接口（100M），一般用于局域网连接，比如电脑网线连接交换机

2. `GigabitEthernet`

   千兆以太网接口（1000M）

3. `Serial`

   串行接口，路由器和路由器之间使用串口连接，路由器和交换机之间连接使用快速以太网口

### 3.6 上网方式

#### 3.6.1 电话线入户

<img src="网络协议.assets/image-20210211175235178.png" alt="image-20210211175235178" style="zoom:50%;" />

`ADSL`电话拨号上网（`Asymmetric Digital Subscriber Line`），非对称数字用户线路，提供上、下不对称的传输带宽。

猫`Modem`，调制解调器，进行数字信号和模拟信号的转换

#### 3.6.2 光纤入户

<img src="网络协议.assets/image-20210211175616729.png" alt="image-20210211175616729" style="zoom:60%;" />

光猫`Optical Modem`，光调制解调器，进行数字信号和光信号的转换

#### 3.6.3 网线入户

<img src="网络协议.assets/image-20210211180401473.png" alt="image-20210211180401473" style="zoom:70%;" />

### 3.7 NAT

NAT：`Network Address Translation`

私网IP访问`Internet`需要进行`NAT`转换为公网`IP`，这一步由路由器完成

`NAT`的特点

- 可以节约公网`IP`资源
- 会隐藏内部真时`IP`

`NAT`的分类

- 静态转换，手动配置`NAT`映射表，一对一转换，不能节约`IP`资源

- 动态转换，定义外部地址池，动态随机转换，也是一对一转换

- `PAT`(Port Address Translation)

  多对一转换，最大程度节约公网`IP`资源

  采用端口多路复用方式，通过端口号标识不同的数据流

  目前应用最广泛的`NAT`实现方式

## 4. 网络分层

![image-20210212090741050](网络协议.assets/image-20210212090741050.png)

OSI模型：国际标准模型

`TCP/IP`协议模型：实际应用的模型

**数据的传送过程**

![image-20210212091045582](网络协议.assets/image-20210212091045582.png)

数据在经过发送方的每一层都会进行一次封装，在接受方则会每一层都进行一次解封装

**不同层的功能**

<img src="网络协议.assets/image-20210212091500465.png" alt="image-20210212091500465" style="zoom:70%;" />

### 4.1 物理层

物理层定义了接口标准、线缆标准、传输速率、传输方式等。

**数字信号、模拟信号**

模拟信号`Analog Signal`：连续的信号，适合长距离传输。抗干扰能力差，收到干扰时波形变形很难纠正

<img src="网络协议.assets/image-20210212092040983.png" alt="image-20210212092040983" style="zoom:67%;" />

数字信号`Digital Signal`：离散的信号，不适合长距离传输，抗干扰能力强，收到干扰时波形可以修复

<img src="网络协议.assets/image-20210212092117282.png" alt="image-20210212092117282" style="zoom:67%;" />

**数据通信模型**

1. 局域网通信模型

   ![image-20210212092357074](网络协议.assets/image-20210212092357074.png)

   网线不能超过**100**米，因为信号会衰减

2. 广域网通信模型

   ![image-20210212092739804](网络协议.assets/image-20210212092739804.png)

**信道Channel**

信息传输的通道，一条传输介质上（比如网线）上可以有多条信道

单工通信：信号只能往一个方向传输，任何时候都不能改变信号的传输方向。比如，无线电广播，有线电视话广播等

半双工通信：信号可以双向传输，但必须是交替执行，同一时间只能往一个方向传输。比如，对讲机等

全双工通信：信号可以同时双向传输。比如，手机等

### 4.2 数据链路层

数据链路层`Data Link`

**链路**：从1个节点到相邻节点的一段物理线路（有线或无线），中间没有其他交换节点

![image-20210212093820980](网络协议.assets/image-20210212093820980.png)

**数据链路**：在一条链路上传输数据时，需要有对应的通信协议来控制数据的传输，不同类型的数据链路，所用的通信协议可能是不同的

1. 广播信道：`CSMA/CD`协议（比如同轴电缆、集线器等组成的网络）
2. 点对点信道：`PPP`协议（比如两个路由器之间的信道）

#### 4.2.1 数据链路层的问题

1. 封装成帧

   <img src="网络协议.assets/image-20210213084253529.png" alt="image-20210213084253529" style="zoom:67%;" />

   帧`Frame`的数据部分：就是网络层传递下来的数据包（`IP`数据包，`Packet`）

   `MTU`最大传输单元`Maximum Transfer Unit`：每一种数据链路层协议都规定了所能够传送的帧的数据长度上限，比如以太网的`MTU`为`1500`个字节

2. 透明传输

   <img src="网络协议.assets/image-20210213084944437.png" alt="image-20210213084944437" style="zoom:60%;" />

   如果数据部分出现`SOH`、`EOT`，就需要进行转义

   <img src="网络协议.assets/image-20210213093611836.png" alt="image-20210213093611836" style="zoom:50%;" />

3. 差错检验

   ![image-20210213094125389](网络协议.assets/image-20210213094125389.png)

   `FCS`是根据数据部分+首部计算得出，用于校验数据的完整性

#### 4.2.2 CSMA/CD协议

`CSMA/CD`（`Carrier Sense Multiple Acess with Collision Detectio`）

功能：载波侦听、多路访问、冲突检测，一般用于集线器所连接的网络使用

使用了`CSMA/CD`的网络可以称为是以太网`Ethernet`，它传输的是以太网帧：以太网帧的格式有：`Ethernet V2`标准（使用最多）、`IEEE`的`802.3`标准

为了能够检测正在发送的帧是否产生了冲突，以太网的帧至少要`64`字节

用交换机组建的网络，已经支持全双工通信，不需要在使用`CSMA/CD`，但它传输的帧依旧是以太网帧，即使用交换机组建的网络，依然可以叫做以太网

#### 4.2.3 Ethernet v2

是数据帧的一种标准传输格式

![image-20210213100701455](网络协议.assets/image-20210213100701455.png)

`Ethernet v2`使用曼斯特编码，不需要帧开始符和帧结束符

首部：目标`MAC`+源`MAC`+网络类型（IPv4&IPv6）

一个完整的以太网帧包括：首部+数据+`FCS`

数据长度至少是：64-6-6-2-4=46字节，最多1500个字节。如果小于46字节，数据链路层不在数据的后面加入一些字节填充

#### 4.2.4 PPP协议

`PPP`协议：`Point to Point Protocol`

![image-20210213101905661](网络协议.assets/image-20210213101905661.png)

- `Address`字段：图中的值是`0xFF`，形同虚设，点到点信道不需要源`MAC`、目标`MAC`地址
- `Control`字段：图中的值是`0x03`，目前没什么用
- `Protocol`字段：内部用到的协议类型
- 帧开始符、帧结束符：`0x7E`

**数据转义**

![image-20210213102708037](网络协议.assets/image-20210213102708037.png)

将`0x7E`替换为`0x7D5E`，将`0x7D`替换为`0x7D5D`

#### 4.2.5 网卡处理数据

<img src="网络协议.assets/image-20210213103002215.png" alt="image-20210213103002215" style="zoom:67%;" />

网卡接受到一个帧，首先进行差错校验，如果校验通过则接收，否则丢弃

`Wireshark`抓到的帧没有`FCS`，因为它抓到的是差错校验通过的帧（`FCS`会被硬件去掉）

### 4.3 网络层

网络层数据包（`IP`数据包，`Packet`）由首部、数据2部分组成，数据一般由传输层传递下来的数据段`Segment`

![image-20210213105458044](网络协议.assets/image-20210213105458044.png)

`wireshark`抓`ping www.qq.com`网络层数据

![image-20210213192323068](网络协议.assets/image-20210213192323068.png)

各部分取值

1. 版本

   占4位，`OB0100`：`IPv4`，`OB0110`：`IPv6`

2. 首部长度

   占4位，二进制值乘4才是最终长度

   `0B0101`：20最小值

   `0B1111`：60最大值

3. 区分服务

   8位，可以提高网络的服务质量

4. 总长度

   网络层的总长度16位，`0<=数据包<=65535`，由于数据链路层的每个数据帧（以太网数据帧）的最大长度为1500字节，所以比较大的`IP`数据包，需要分成片`fragments`传输给数据链路层，每一片都有自己的网络层首部（`IP`首部）

5. 标识`Identification`

   占16位，表示为数据包的`ID`，当数据包过大进行分片时，同一个数据包的所有片的标识都是一样的

   有一个计数器专门管理数据包的`ID`，每发出一个数据包，`ID`就加1

6. 标志`flags`

   占三位

   第一位`Reserved Bit`：保留

   第二位`Don't Fragment`：1代表不允许分片，0代表允许分片

   第三位`More Fragments`：1代表不是最后一片，0代表是最后一片

7. 片偏移`Fragment Offset`

   占13位，片偏移乘以8：字节偏移

   每一片的长度一定是8的整数倍

   ![image-20210213172715591](网络协议.assets/image-20210213172715591.png)

8. 生存时间

   生存时间`Time To Live, TTL`，占8位

   每个路由器在转发之前会将`TTL`减1，一旦发现`TTL`减为0，路由器就会返回错误报告

   | 操作系统 | 版本                      | 默认TTL |
   | -------- | ------------------------- | ------- |
   | Windows  | Server 2003，XP，7，10    | 128     |
   | Linux    | 2.0.x Kernel，Red Hat 9   | 64      |
   | Linux    | 2.2.14 Kernel，2.4 Kernel | 255     |
   | Mac OS   |                           | 60      |
   | Mac OS X |                           | 64      |

9. 协议

   占8位，表明所封装的数据是使用了什么协议

   | 协议   | ICMP | IGMP | IP   | TCP  | EGP  | IGP  | UDP  | IPv6 | ESP  | OSPF |
   | ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
   | 十进制 | 1    | 2    | 4    | 6    | 8    | 9    | 17   | 41   | 50   | 89   |

10. 首部检验和

    占16位，用于检测首部是否正确。

11. 源IP

12. 目标Ip

### 4.4 传输层

传输层有两个协议

- `TCP(Transmission Control Protocol)`：传输控制协议
- `UDP(User Datagram Protocol)`：用户数据报协议

| 特性         | TCP                         | UDP                                  |
| ------------ | --------------------------- | ------------------------------------ |
| 连接性       | 面向连接                    | 无连接                               |
| 可靠性       | 可靠传输、不丢包            | 不可靠传输，尽最大努力交付，可能丢包 |
| 首部占用空间 | 大                          | 小                                   |
| 传输速率     | 慢                          | 快                                   |
| 资源消耗     | 大                          | 小                                   |
| 应用场景     | 浏览器、文件传输、邮件发送  | 音视频通话、直播                     |
| 应用层协议   | HTTP、HTTPS、FTP、SMTP、DNS | DNS                                  |

#### 4.4.1 UDP

`UDP`是无连接的，减少了建立和释放连接的开销，`UDP`尽最大能力交付，不保证可靠交付。因此不需要维护一些复杂的参数，首部只有8个字节

数据格式

![image-20210213200417043](网络协议.assets/image-20210213200417043.png)

1. `UDP`长度

   长度是指这一个`UDP`数据包的总长度，这个字段的设计是为了保证首部是32bit对齐，因为数据包的长度可以由网络层`IP`数据包的首部推测出来

2. `UDP`检验和

   检验和的计算内容：伪首部 + 首部 + 数据

<img src="网络协议.assets/image-20210213200749930.png" alt="image-20210213200749930" style="zoom:50%;" />

伪首部只在计算校验和时生效，并不会传送给网络层

#### 4.4.2 TCP数据格式

![image-20210214103809588](网络协议.assets/image-20210214103809588.png)

1. 序号

   `Sequence Number`：占4字节，首先，在传输过程的每一个字节都会有一个编号，在建立连接后，序号代表：这一次传给对方的`TCP`数据部分的第一个字节的编号

2. 确认号

   `Acknowledgment Number`：占4字节，在建立连接后，确认号代表：期望对方下一次传过来的`TCP`数据部分的第一个字节的编号

3. 数据偏移

   占4位，首部长度，需要乘以4，取值范围20~60

4. 保留位

   占6位，目前全为0

5. 标志位

   占6位，取值代表不同的意思

   `URG`(Urgent)：当`URG=1`时，紧急指针字段才有效。表明当前报文字段中有紧急数据，应优先尽快传送

   `ACK`(Acknowledgement)：当`ACK=1`时，确认号字段才有效

   `PSH`(Push)

   `RST`(Reset)：当`RST=1`时，表明连接中出现严重差错，必须释放连接，然后再重新建立连接

   `SYN`(Synchromization)：当`SYN=1`、`ACK=0`时，表明这是一个建立连接的请求；若对方同意建立连接，则回复`SYN=1`、`ACK=1`

   `FIN`(Finsh)：当`FIN=1`时，表明数据已经发送完毕，要求释放连接

6. 窗口

   占2字节

   具有流量控制功能，告诉对方预留的缓冲区大小

7. 检验和

   跟`UDP`一样，`TCP`检验和的计算内容：伪首部+首部+数据

   伪首部占12字节，只在计算检验和时有效

8. 紧急指针

   数字表示`TCP`数据部分的前几位是紧急数据，需要优先传送

#### 4.4.3 TCP可靠传输

**停止等待ARQ协议**

`ARQ`(Automatic Repeat-request)，自动重传请求

- 超时重传

![image-20210214210649285](网络协议.assets/image-20210214210649285.png)

- 确认丢失

![image-20210214211020210](网络协议.assets/image-20210214211020210.png)

**连续ARQ协议+滑动窗口协议**

![image-20210215133613005](网络协议.assets/image-20210215133613005.png)

**选择性确认**

在`TCP`通信过程中，如果发送序列中间某个数据包丢失（比如1、2、3、4、5中的3丢失了），如果正常情况下会重传(3、4、5)。4和5就属于重复发送，为了解决上述问题，发展出了`SACK`(Selective Acknowledgment，选择性确认)技术，可以告诉发送放哪些数据已经发送成功，哪些发送失败需要重新发送。

<img src="网络协议.assets/image-20210215145711992.png" alt="image-20210215145711992" style="zoom:50%;" />

`SACK`信息放在`TCP`首部的选项部分

- `Kind`：占1字节。值为5代表这是`SACK`选项
- `Length`：占1字节。表明`SACK`选项一共占用多少字节
- `Left Edge`：占4字节。左边界
- `Right Edge`：占4字节。右边界

![image-20210215150858248](网络协议.assets/image-20210215150858248.png)

一对边界信息需要占8字节，由于`TCP`首部的选项部分最多40字节，所以`SACK`选项最多携带4组边界信息

对于重传的数据包如果超过一定的重传次数，仍然传输失败（未收到对方的确认报文），则会断开连接，重新建立

#### 4.4.4 TCP流量控制

让发送方的发送速率不要太快，让接受方能够及时处理，主要原理是通过确认报文中窗口字段来控制发送方的发送速率，如果接受窗口的大小为0，则发送方会停止发送

**特殊情况**

第一次接受方发送0窗口的报文字段，但在后面接受方有了一些存储空间，给发送方发送的非0窗口的报文段丢失了，双方会陷入僵局。解决方案：当发送发接收到0窗口通知时，这时发送方停止发送报文，并且同时开启一个定时器，隔一段时间之后就发个测试报文去询问接受方最新的窗口大小，如果还是0则会再次启动定时器

#### 4.4.5 TCP拥塞控制

<img src="网络协议.assets/image-20210218084340217.png" alt="image-20210218084340217" style="zoom:67%;" />

**拥塞控制**

防止过多的数据注入到网络中，避免网络中的路由器或链路过载。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器以及与降低网络传输性能有关的所有因素

**几个缩写**

`MSS`（Maximum Segment Size）：每个段最大的数据部分大小，连接时由双方协商确定

`cwnd`（congestion window）：拥塞窗口

`rwnd`（receive window）：接受窗口

`swnd`（send window）：发送窗口

```java
swnd = min(cwnd, rwnd)
```

**拥塞控制的方法**

1. 慢开始（slow start）

   ![image-20210218151606670](网络协议.assets/image-20210218151606670.png)

   发送时，刚开始慢，后面越来越快。`cwnd`的初始值比较小，然后随着数据包被接受方确认（收到一个ACK）之后成指数级增长

2. 拥塞避免（congestion avoidance）

   ![image-20210218152151150](网络协议.assets/image-20210218152151150.png)

   `ssthresh`（slow start threshold）：慢开始阈值，`cwnd`达到阈值后，以线性方式增加。拥塞窗口缓慢增大，以防止网络过早出现拥塞

   乘法减小：只要网络出现拥塞，把`ssthresh`减半，与此同时，执行慢开始算法（`cwnd`又恢复到初始值）

3. 快速重传（fast retransmit）

   ![image-20210218154923271](网络协议.assets/image-20210218154923271.png)

   接受方：每收到一个失序的分组后就立即发出重复确认，使发送方及时知道有分组没有到达，而不要等待自己发送数据时才进行确认

   发送方：只要连续收到三个重复确认（总共4个相同的确认），就应当立即重传对方尚未收到的报文段，而不必继续等待重传计时器到期后再重传

4. 快速恢复（fast recovery）

   ![image-20210218155714515](网络协议.assets/image-20210218155714515.png)

当发送方连续收到三个重复确认，就执行"乘法减小"算法，把`ssthresh`减半，与蛮开始不同之处是现在不执行慢开始算法，即`cwnd`现在不恢复到初始值，而是把`cwnd`值设置为`ssthresh`减半后的数值，人后开始执行拥塞避免算法（"线性增大"），使拥塞窗口缓慢地线性增大

#### 4.4.6 TCP建立连接

<img src="网络协议.assets/image-20210218193312886.png" alt="image-20210218193312886" style="zoom:50%;" />

**客户端申请建立连接**

![image-20210218193808063](网络协议.assets/image-20210218193808063.png)

**服务器发送数据**

![image-20210218202859094](网络协议.assets/image-20210218202859094.png)

**客户端确认**

![image-20210218204210161](网络协议.assets/image-20210218204210161.png)

**三次握手**

<img src="网络协议.assets/image-20210219111043177.png" alt="image-20210219111043177" style="zoom:50%;" />

`CLOSED`：`client`处于关闭状态

`LISTEN`：`server`处于监听状态，等待`client`连接

`SYN-RCVD`：表明`server`接收到了`SYN`报文，当收到`client`的`ACK`的报文后，它会进入到`ESTABLISHED`状态

`SYN-SEND`：表明`client`已发送`SYN`报文，等待`server`的第2次握手

`ESTABLISHED`：连接已经建立

前两次的握手中头部占32字节，固定20字节+选项12字节

**三次握手的目的**

3次握手的主要目的是防止`server`端一直等待，浪费资源。假设有如下情况

一个`client`发出的第一个连接请求报文段，因为网络延迟，在第二次连接已经释放后的某个时间才到达`server`，这是一个已经失效的连接请求，但`server`收到后，误以为是`client`再次发出的一个新的连接请求，于是`server`就想`client`发出确认报文段，同意建立连接，但是因为是两次握手，只要`server`发出确认，新的连接就建立了。由于现在的`client`并没有真正想连接服务器的意愿，因此不会理睬`server`的确认报文段，但是`server`却以为新的连接已经建立，并一直等待`client`发来的数据，这样，`server`的很多资源就浪费了

第三次握手失败情况

此时`server`的状态为`SYN-RCVD`，若等不到`client`的`ACK`，`server`会重新发送`SYN`+`ACK`包，如果`server`多次重发`SYN`+`ACK`都等不到`client`的`ACK`，就会发送`RST`包，强制关闭连接

#### 4.4.7 TCP断开连接

**四次挥手**

<img src="网络协议.assets/image-20210219120852785.png" alt="image-20210219120852785" style="zoom:50%;" />

**状态解读**

1. `FIN-WAIT-1`：表示想主动关闭连接

   向对方发送`FIN`报文，此时进入到`FIN-WAIT-1`状态

2. `CLOSE-WAIT`：表示在等待关闭

   当对方发送`FIN`给自己，自己会回应一个`ACK`报文给对方，此时则进入到`CLOSE-WAIT`状态，在此状态下，需要考虑自己是否还有数据要发送给对方，如果没有，发送`FIN`报文给对方

3. `FIN-WAIT-2`：只要对方发送`ACK`确认后，主动方就会处于`FIN-WAIT-2`状态，然后等待对方发送`FIN`报文

4. `CLOSING`：一种比较罕见的例外状态，标识双方都正在关闭连接

   表示你发送`FIN`报文后，并没有收到对方的`ACK`报文，反而却收到了对方的`FIN`报文

   如果双方几乎在同时准备关闭连接的话，那么就出现了同时发送`FIN`报文的情况，也会出现`CLOSING`状态

5. `LAST-ACK`：被动关闭一方在发送`FIN`报文后，最后等待对方的`ACK`报文

   当收到`ACK`报文后，即可进入`CLOSED`状态

6. `TIME-WAIT`：表示收到了对方的`FIN`报文，并发送出了`ACK`报文，就等`2MSL`后即可进入`CLOSED`状态了

   如果在`FIN-WAIT-1`状态下，收到了对方同时带`FIN`标志和`ACK`标志的报文时，可直接进入到`TIME-WAIT`状态，而无需经过`FIN-WAIT-2`状态

7. `CLOSED`：关闭状态

   由于有些状态的时间比较短暂，所以很难用`netstat`命令看到

**为什么需要四次挥手**

1. 当主机1(client)发出`FIN`报文段时

   表示主机1告诉主机2(server)，主机1已经没有数据要发送了，但是，此时主机1还是可以接受来自主机2的数据

2. 当主机2返回`ACK`报文段时

   表示主机2已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的

3. 当主机2也发送了`FIN`报文段时

   表示主机2告诉主机1，主机2已经没有数据要发送了

4. 当主机1返回`ACK`报文段时

   表示主机1已经知道主机2没有数据发送了，随后正式断开整个`TCP`连接

**释放连接的细节**

1. `TCP/IP`协议栈在设计上，允许任何一方先发起断开请求。

2. `client`发送`ACK`后，需要有个`TIME-WAIT`阶段，等待一段时间后，再真正关闭连接

   一般等待2倍的`MSL`（`Maximum Segment Lifetime`，最大分段生存期）

   `MSL`是`TCP`报文在`Internet`上的最长生存时间，每个具体的`TCP`实现都必须选择一个确定的`MSL`值，`RFC 1122`建议是2分钟

3. 如果`client`发送`ACK`后马上释放了，然后又因为网络原因，`server`没有收到`client`的`ACK`，`server`就会重发`FIN`

   可能出现的情况

   - `client`没有任何回应，服务器一直等待，甚至多次重发`FIN`，浪费资源
   - `client`有个新的应用程序刚好分配了同一个端口，新的应用程序收到`FIN`后马上开始执行断开连接的操作

4. 有的时候使用抓包工具时，可能只会看到3次挥手

   这其实是将第2、3次挥手合并了

   当`server`接受到`client`的`FIN`时，如果`server`后面也没有数据要发送给`client`了，这时`server`就可以将第2、3次合并，回复结果中包括告诉`client`已经收到它的断开请求，告诉`client`已经没有数据要发了

### 4.5 应用层

常见的协议

- 超文本传输：`HTTP`、`HTTPS`
- 文件传输：`FTP`
- 电子邮件：`SMTP`、`POP3`、`IMAP`
- 动态主机配置：`DHCP`
- 域名系统：`DNS`

#### 4.5.1 域名

由于`IP`地址不方便记忆，并且不能表达组织的名称和性质，人们设计出了域名`Domain Name`，实际上为了能够访问具体的主机，最终还是得知道目标主机的`IP`地址

根据级别的不同，域名可以分为

- 顶级域名

  通用顶级域名（General Top-level Domain，简称gTLD）

  `.com`公司、`.net`网络机构、`.org`组织机构、`.edu`教育、`.gov`政府部门、`.int`国际组织...

  国家及地区顶级域名（Country code Top-level Domain，简称ccTLD）

  `.cn`中国、`.jp`日本、`.uk`英国...

  新通用顶级域名（New Generic Top-level Domain，简称New gTLD）

  `.vip`、`.xyz`、`.top`、`.club`、`.shop`...

- 二级域名，顶级域名之下的域名

  在通用顶级域名之下的域名，它一般指域名注册人的名称，例如`google`、`baidu`、`microsoft`...

  在国家及地区域名下，它一般指注册类别的，例如`com`、`edu`、`gov`、`net`等

  ![image-20210219164803428](网络协议.assets/image-20210219164803428.png)

- 三级域名

- ...

#### 4.5.2 DNS

`DNS`的全称是：`Domain Name System`，译为：域名系统。利用`DNS`协议，可以将域名（比如`baidu.com`）解析成对应的`IP`地址`220.181.38.148`

`DNS`可以基于`UDP`协议，也可以基于`TCP`协议，服务器占用53端口

![image-20210219171311319](网络协议.assets/image-20210219171311319.png)

**DNS服务器**

1. 客户端首先会访问最近的一台`DNS`服务器（或者是客户端自己配置的`DNS`服务器）
2. 所有的`DNS`服务器都记录了`DNS`根服务器的`IP`地址
3. 上级`DNS`服务器记录了下一级`DNS`服务器的`IP`地址
4. 全球一共13台`IPv4`的`DNS`根域名服务器、25台`IPv6`的`DNS`根域名服务器

#### 4.5.3 DHCP

`IP`地址按照分配方式，可以分为：静态`IP`地址、动态`IP`地址

- 静态`ip`地址

  手动设置

  使用场景：不怎么挪动的台式机（比如学校机房中的台式机）、服务器等

- 动态`IP`地址

  从`DHCP`服务器自动获取`IP`地址

  使用场景：移动设备、无线设备等

`DHCP`（Dynamic Host Configuraiton Protocol）：动态主机配置协议，`DHCP`协议是基于`UDP`协议，客户端是68端口，服务器是67端口

`DHCP`服务器会从`IP`地址池中，挑选一个`IP`地址“出租”给客户端一段时间，时间到期就回收它们，平时家里上网的路由器可以充当`DHCP`服务器

**DHCP分配流程**

1. `DISCOVER`：发现服务器

   发广播包(源`IP`是`0.0.0.0`，目标是`255.255.255.255`，目标`MAC`是`FF:FF:FF:FF:FF:FF`)

2. `OFFER`：提供租约

   服务器返回可以租用的`IP`地址，以及租用期限、子网掩码、网管、`DNS`等信息，可能会有多个服务器提供租约

3. `REQUEST`：选择`IP`地址

   客户端选择一个`OFFER`，发送广播包进行回应

4. `ACKNOWLEDGE`：确认

   被选中的服务器发送`ACK`数据包给客户端，`IP`地址分配完毕

**细节**

1. `DHCP`服务器可以借助`DHCP`中继代理（`DHCP Relay Agent`）实现跨网段分配`IP`地址（假设`DHCP`服务器、客户端不在同一个网段）
2. 自动续约：客户端会在租期不足的时候，自动向`DHCP`服务器发送`REQUEST`信息申请续约

#### 4.5.4 HTTP

`HTTP`（Hyper Text Transfer Protocol）：超文本传输协议，是互联网中应用最广泛的应用层协议之一。设计`HTTP`最初的目的是：提供一种发布和接受`HTML`页面的方法，由`URI`来标识具体的资源；后面用`HTTP`传递的数据格式不仅仅是`HTML`，应用非常广泛

`HTTP`的标准是由万维网协会`W3C`、互联网工程任务组`IETF`协调指定，最终发布的一系列的`RFC`（Request For Comments，可以译为：请求意见稿）

**版本**

1. 1991年`HTTP/0.9`，只支持`GET`请求方法获取文本数据（比如`HTML`文档），且不支持请求头、响应头等，无法向服务器传递太多信息
2. 1996年`HTTP/1.0`，支持`POST`、`HEAD`等请求方法，支持请求头、响应头等，支持更多种数据类型（不再局限于文本数据），浏览器每次请求都需要与服务器建立一个`TCP`连接，请求处理完成后立即断开`TCP`连接
3. 1997年`HTTP/1.1`，最经典、使用最广泛的版本。支持`PUT`、`DELETE`等请求方法，采用持久连接`Connection: keep-alive`，多个请求可以共用一个`TCP`连接
4. 2015年`HTTP/2.0`
5. 2018年`HTTP/3.0`

**报文格式**

![image-20210219204320592](网络协议.assets/image-20210219204320592.png)

1. 请求报文

   ```yaml
   POST /s1/login HTTP/1.1
   Host: localhost:8080
   Connection: keep-alive
   Content-Length: 25
   Cache-Control: max-age=0
   Upgrade-Insecure-Requests: 1
   Origin: http://localhost:8080
   Content-Type: application/x-www-form-urlencoded
   User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.182 Safari/537.36 Edg/88.0.705.74
   Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
   Sec-Fetch-Site: same-origin
   Sec-Fetch-Mode: navigate
   Sec-Fetch-User: ?1
   Sec-Fetch-Dest: document
   Referer: http://localhost:8080/s1/html/login.html
   Accept-Encoding: gzip, deflate, br
   Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6,zh-TW;q=0.5
   Cookie: JSESSIONID=FE9FD8715D870123295BBC401B6DB7E6; Idea-9729ea=64ab6b25-3255-43ab-9637-7c28d339adb8
   
   username=123&password=456
   ```

2. 响应报文

   ```yaml
   HTTP/1.1 200 
   Content-Length: 16
   Date: Fri, 19 Feb 2021 12:37:46 GMT
   Keep-Alive: timeout=20
   Connection: keep-alive
   
   Login Success!!!
   ```

**ABNF**

`ABNF`（Augmented BNF）是`BNF`（Backus-Naur Form，巴科斯-瑙尔范式）的修改、增强版，`ABNF`用作`internet`中通信协议的定义语言

整体格式

```ABNF
HTTP-message = start-line * (header-field CRLF) CRLF [message-body]
```

- `start-line`：请求行`request-line`或者响应行`status-line`
- `*`：0个或者多个。2*表示至少2个，3\*6表示3到6个
- `()`：组成一个整体
- `[]`：可选

**URL编码**

`URL`中一旦出现了一些特殊字符（比如中文、空格），需要进行编码，在浏览器地址栏输入`URL`时，是采用`UTF-8`进行编码

**请求方法**

1. `GET`：常用于读取的操作，请求参数直接拼接在`URL`的后面（浏览器对`URL`是有长度限制的）
2. `POST`：常用于添加、修改、删除的操作，请求参数可以放到请求体中（没有大小限制）
3. `HEAD`：请求得到与`GET`请求相同的响应，但没有响应体（即只获取响应头）
4. `OPTIONS`：用于获取目的资源所支持的通信选项，比如服务器支持的请求方法
5. `PUT`：用于对已存在的资源进行整体覆盖
6. `PATCH`：用于对资源进行部分修改（资源不存在，会创建新的资源）
7. `DELETE`：用于删除指定的资源
8. `TRACE`：请求服务器回显其收到的请求信息，主要用于`HTTP`请求的测试或诊断
9. `CONNECT`：可以开启一个客户端与所请求资源之间的双向沟通的通道，它可以用来创建隧道`tunnel`，可以用来访问采用了`SSL(HTTPS)`协议的站点

**头部字段**

类型

- 请求头字段`Request Header Fields`，有关要获取的资源或客户端本身信息的消息头
- 响应头字段`Response Header Fields`，有关响应的补充信息，比如服务器本身（名称和版本等）的消息头
- 实体头字段`Entity Header Fields`，有关实体主体的更多信息，比如主体长度`Content-Length`或者`MIME`类型
- 通用头字段`General Header Fields`，同时适用于请求和响应消息，但与消息主体无关的消息头

请求头字段

| 头部字段        | 说明                                                         | 示例                                                         |
| --------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| User-Agent      | 浏览器的身份标识字符串                                       | User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.182 Safari/537.36 Edg/88.0.705.74 |
| Host            | 服务器的域名、端口号                                         | Host: localhost:8080                                         |
| Date            | 发送消息的日期和时间                                         | Date: Fri, 19 Feb 2021 12:37:46 GMT                          |
| Referer         | 表示浏览器所访问的前一个页面，正是那个页面上的某个链接将浏览器带到了当前所请求的这个页面 | Referer: https://www.baidu.com                               |
| Content-Type    | 请求体的类型                                                 | Content-Type: application/x-www-form-urlencoded              |
| Content-Length  | 请求体的长度（字节）                                         | Content-Length: 16                                           |
| Accept          | 能够接受的响应内容类型（Content-Types）                      | Accept: text/plain                                           |
| Accept-Charset  | 能够接受的字符集                                             | Accept-Charset: utf-8                                        |
| Accept-Encoding | 能够接受的编码方式列表                                       | Accept-Encoding: gzip, deflate                               |
| Accept-Language | 能够接受的响应内容的自然语言列表                             | Accept-Language: en-US                                       |
| Range           | 仅请求某个实体的一部分。字节偏移以0开始                      | Range: bytes=500-999                                         |
| Origin          | 发起一个针对跨域资源共享的请求                               | Origin: https://www.baidu.com                                |
| Cookie          | 之前由服务器通过Set-Cookie发送的Cookie                       | Cookie: $Version=1; Skin=new;                                |
| Connection      | 该浏览器想要优先使用的连接类型                               | Connection: keep-alive                                       |
| Cache-Control   | 用来指定在这次的请求/响应链中的所有缓存机制都必须遵守的指令  | Cache-Control: no-cache                                      |

响应头字段

| 字段名                      | 说明                                                         | 示例                                                  |
| --------------------------- | ------------------------------------------------------------ | ----------------------------------------------------- |
| Date                        | 发送消息的日期和时间                                         | Date: Fri, 19 Feb 2021 12:37:46 GMT                   |
| Last-Modified               | 所请求的对象的最后修改日期                                   | Last-Modified: Tue, Fri, 19 Feb 2021 12:37:46 GMT     |
| Server                      | 服务器的名字                                                 | Server: Apache/2.4.1 (Unix)                           |
| Expires                     | 指定一个时间，超过改时间认为此响应已经过期                   | Expires: Tue, Fri, 19 Feb 2021 12:37:46 GMT           |
| Content-Type                | 响应体的类型                                                 | Content-Type: text/html; charset=utf-8                |
| Content-Encoding            | 内容所使用的编码类型                                         | Content-Encoding: gzip                                |
| Content-Length              | 响应体的长度（字节为单位）                                   | Content-Length: 348                                   |
| Content-Disposition         | 一个可以让客户端下载文件并建议文件名的头部                   | Content-Disposition: attachment; filename="fname.ext" |
| Accept-Ranges               | 服务器支持哪些种类的部分内容范围                             | Accept-Ranges: bytes                                  |
| Content-Range               | 这条消息是属于完整消息的哪部分                               | Content-Range: bytes 21010-47021/47022                |
| Access-Control-Allow-Origin | 指定哪些网站可参与到跨域资源共享文件过程中                   | Access-Control-Allow-Origin: *                        |
| Location                    | 用来进行重定向，或者在创建了某个新资源时使用                 | Location: http://www.baidu.com                        |
| Set-Cookie                  | 返回一个Cookie让客户端去保存                                 | Set-Cookie: UserID=xxxxxxxxx                          |
| Connection                  | 针对该连接所预期的选项                                       | Connection: close                                     |
| Cache-Control               | 向从服务器直到客户端在内的所有缓存机制告知，他们是否可以缓存这个对象。单位秒 | Cache-Control: max-age=1000                           |

**状态码**

分类

1. 信息响应：`100~199`
2. 成功响应：`200~299`
3. 重定向：`300~399`
4. 客户端错误：`400~499`
5. 服务器错误：`500~599`

常见的状态码

- 100`continue`，请求的初始部分已经被服务器收到，并且没有被服务器拒绝。客户端应该继续发送剩余的请求，如果请求已经完成，就忽略这个响应。允许客户端发送带请求体的请求前，判断服务器是否愿意接受请求（服务器通过请求头判断）。在某些情况下，如果服务器在不看请求体就拒绝请求时，客户端就发送请求体是不恰当的或低效的
- 200`ok`，请求成功
- 302`found`，请求的资源被暂时的移动到了由`location`头部指定的`URL`上
- 304`not modified`，说明无需再次传输请求的内容，也就是说可以使用缓存的内容
- 400`bad request`，由于语法无效，服务器无法理解该请求
- 401`unauthorized`，由于缺乏目标资源要求的身份验证凭证
- 404`not found`，服务器端无法找到所请求的资源
- 405`method not allowed`，服务器禁止了使用当前`HTTP`方法的请求
- 406`not acceptable`，服务器端无法提供与`Accept-Charset`以及`Accept-Language`指定的值相匹配的响应
- 408`request timeout`，服务器想要将没有在使用的连接关闭，一些服务器会在空闲连接上发送此信息，即便是在客户端没有发送任何请求的情况下
- 500`internal server error`，所请求的服务器遇到意外的情况并阻止其执行请求
- 501`not implemented`，请求的方法不被服务器支持，因此无法被处理，服务器必须支持的方法只有`GET`和`HEAD`
- 502`bad gateway`，作为网关或代理角色的服务器，从上游服务器（如`tomcat`）中接受到的响应式无效的
- 503`service unavailable`，服务器尚处于可以接受请求的状态，可能是服务器停机维护或过载

**跨域**

- 解决`AJAX`跨域请求的常用方法

  `CORS(Cross-Origin Resource Sharing)`，跨域资源共享

- `CROS`的实现需要客户端和服务器同时支持

  客户端：所有浏览器都支持

  服务器：需要返回相应的响应头（比如`Access-Control-Allow-Origin`），告诉浏览器这是一个允许跨域访问的请求

#### 4.5.5 HTTPS

`HTTPS(HyperText Transfer Protocol Secure)`，超文本传输安全协议。也被称为`HTTP over TLS`、`HTTP over SSL`、`HTTP Secure`，`HTTPS`的默认端口号是`443`

`HTTPS`是在`HTTP`的基础上使用`SSL/TLS`来加密报文，对窃听和中间人攻击提供合理的防护。`SSL/TLS`也可以用在其他协议上，比如`FTP`-->`FTPS`、`SMTP`-->`SMTPS`

`TLS(Transport Layer Security)`：传输层安全协议前身是`SSL(Secure Sockets Layer)`安全套接层，`SSL/TLS`工作在应用层和传输层之间

<img src="网络协议.assets/image-20210222083950851.png" alt="image-20210222083950851" style="zoom:50%;" />

`HTTPS`的通讯过程

<img src="网络协议.assets/image-20210222085602864.png" alt="image-20210222085602864" style="zoom:50%;" />

1. `TCP`的3次握手
2. `TLS`的连接
3. `HTTP`请求和响应

**TLS连接的关键步骤**

<img src="网络协议.assets/image-20210222094054568.png" alt="image-20210222094054568" style="zoom:50%;" />

1. `Client Hello`

   `TLS`的版本号，支持的加密组件`Clipher Suite`列表（加密组件是指所使用的加密算法及密钥长度等），一个随机数`Client Random`

   <img src="网络协议.assets/image-20210222100354425.png" alt="wireshark抓包" />

2. `Server Hello`

   `TLS`的版本号，选择的加密组件（是从接收到的客户端加密组件列表中挑选出来的），一个随机数

   <img src="网络协议.assets/image-20210222100434999.png" alt="image-20210222100434999"/>

3. `Certificate`

   服务器的公钥证书（被CA签名过）

   <img src="网络协议.assets/image-20210222100520486.png" alt="image-20210222100520486" />

4. `Server Key Exchange`

   用以实现`ECDHE`算法的其中一个参数`Server Params`(`ECDHE`是一种密钥交换算法，为了防止伪造，`Server Params`经过了服务器私钥签名）

   <img src="网络协议.assets/image-20210222100836077.png" alt="image-20210222100836077"/>

5. `Server Hello Done`

   告知客户端，协商结束

   ![image-20210222101103662](网络协议.assets/image-20210222101103662.png)

6. `Client Key Exchange`

   发送用以实现`ECDHE`算法的另一个参数`Client Params`

   ![image-20210222101555895](网络协议.assets/image-20210222101555895.png)

   目前，客户端和服务器都拥有了`ECDHE`算法需要的2个参数：`Server Params`、`Client Params`。客户端、服务器都可以使用`ECDHE`算法根据`Server Params`、`Client Params`计算出一个新的随机字符串`Pre-master secret`。然后结合`Client Random`、`Server Random`、`Pre-master secret`生成一个主密钥，使用主密钥衍生出客户端发送的会话密钥、服务器发送的会话密钥等

7. `Change Cipher Spec`

   告知服务器，之后的通信采用计算出来的会话密钥进行加密

   ![image-20210222102408322](网络协议.assets/image-20210222102408322.png)

8. `Finished`

   包含连接至今全部报文的整体校验值（摘要），加密之后发送给服务器

   ![image-20210222102551886](网络协议.assets/image-20210222102551886.png)

9. 10. 服务器发送的`Change Cipher Spec`、`Finished`

   到此为止，客户端服务器都验证加密解密没有问题，握手正式结束，后面开始传输加密的`HTTP`请求和响应

   ![image-20210222102408322](网络协议.assets/image-20210222102408322.png)

   ![image-20210222102551886](网络协议.assets/image-20210222102551886.png)

#### 4.5.6 SPDY

<img src="网络协议.assets/image-20210222113723350.png" alt="image-20210222113723350" style="zoom:50%;" />

`SPDY(speedy)`，是基于`TCP`的应用层协议，它强制要求使用`SSL/TLS`。`SPDY`并不用于取代`HTTP`，它只是修改了`HTTP`请求于响应的传输方式。只需要增加一个`SPDY`层，现有的所有服务端应用均不用做任何修改。

`SPDY`是`HTTP/2`的前身

#### 4.5.7 HTTP/2

`HTTP/2`在底层传输做了很多的改进和优化，但在语意上完全与`HTTP/1.1`兼容（比如请求头、响应码等没有改变）

**HTTP/2的特性**

1. 二进制格式

   采用二进制格式传输数据，而非`HTTP/1.1`的文本格式

   <img src="网络协议.assets/image-20210222115305771.png" alt="image-20210222115305771" style="zoom:50%;" />

   数据流：已建立的连接内的双向字节流，可以承载一条或多条消息。所有的通信都在一个`TCP`连接上完成，此连接可以承载任意数量的双向数据流

   消息：与逻辑`HTTP`请求或响应消息对应，由一系列帧组成

   帧：`HTTP/2`通信的最小单位，每个帧都包含帧头（会标识出当前帧所属的数据流），来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据标识符重新组装

2. 多路复用`Multiplexing`

   <img src="网络协议.assets/image-20210222120606370.png" alt="image-20210222120606370" style="zoom:50%;" />

   客户端和服务器可以将`HTTP`消息分解为互不以来的帧，然后交错发送，最后再在另一端把他们重新组装起来

   并行交错地发送多个请求，请求之间互不影响

   并行交错地发送多个响应，响应之间互不影响

   使用一个连接并行发送多个请求和响应

3. 优先级

   `HTTP/2`标准允许每个数据流都有一个关联的权重和依赖关系，可以向每个数据流分配一个1至256之间的整数，每个数据流与其他数据流之间可以存在显示依赖关系

   客户端可以构建和传递"优先级树"，表明它倾向于如何接受响应

   服务器可以使用此信息通过控制CPU、内存和其他资源的分配设定数据流处理的优先级，在资源数据可用之后，确保将高优先级响应以最优的方式传输至客户端

   <img src="网络协议.assets/image-20210222123410978.png" alt="image-20210222123410978" style="zoom:50%;" />

   - 应尽可能先给父数据流分配资源

   - 同级数据流（共享相同父项）应按其权重比例分配资源

4. 头部压缩

   <img src="网络协议.assets/image-20210222123945994.png" alt="image-20210222123945994" style="zoom:50%;" />

   `HTTP/2`使用`HPACK`压缩请求头和响应头，可以极大减少头部开销，进而提高性能

5. 服务器推送

   <img src="网络协议.assets/image-20210222124915234.png" alt="image-20210222124915234" style="zoom:50%;" />

   服务器可以对一个客户端请求发送多个响应，除了最初的响应外，服务器还可以向客户端推送额外资源，而无需客户端额外明确地请求

**HTTP/2的问题**

1. 队头阻塞

   <img src="网络协议.assets/image-20210222125422820.png" alt="image-20210222125422820" style="zoom:50%;" />

   假设在传输过程中，红色的数据包丢失，剩下的数据不能够传输到应用层，而是等待红色的数据包重传

2. 握手延迟

   <img src="网络协议.assets/image-20210222125759032.png" alt="image-20210222125759032" style="zoom:50%;" />

#### 4.5.8 HTTP/3

`Google`开发的基于`UDP`协议的`QUIC`协议，后改名`HTTP/3`

<img src="网络协议.assets/image-20210222130037226.png" alt="image-20210222130037226" style="zoom:50%;" />

数据的可靠传输由`QUIC`协议来保证

**HTTP/3的特性——连接迁移**

`TCP`基于4要素（源IP、源端口、目标IP、目标端口），切换网络时至少有一个要素发生变化，导致连接发生变化。当连接发生变化时，就会连接失败重新建立连接

`QUIC`的连接不受4要素的影响，当4要素发生变化时，原连接依然维持。`QUIC`连接不以4要素作为标识，而是使用一组`Connection ID(连接ID)`来标识一个连接，即使`IP`或者端口发生变化，只要`Connection ID`没有变化，那么连接依然可以维持

**HTTP/3的问题——操作系统内核、CPU负载**

与传统的`TLS`的`HTTP/2`相比，大规模部署的`QUIC`需要近2倍的`CPU`使用量，原因是因为`Linux`内核的`UDP`部分没有像`TCP`那样的优化，因为传统上没有使用`UDP`进行如此高速的信息传输，并且`TCP`和`TLS`有硬件加速。

## 5. 网络基础知识

### 5.1 代理服务器

<img src="网络协议.assets/image-20210221111459770.png" alt="image-20210221111459770" style="zoom:50%;" />

代理服务器`Proxy Server`特点：本身不生产内容，处于中间位置转发上下游的请求和响应

#### 5.1.1 正向代理

**正向代理**：代理的对象是客户端

<img src="网络协议.assets/image-20210221112143833.png" alt="image-20210221112143833" style="zoom:50%;" />

**作用**

1. 隐藏客户端身份

2. 绕过防火墙（突破访问限制）

   <img src="网络协议.assets/image-20210221112437199.png" alt="image-20210221112437199" style="zoom:50%;" />

3. `Internet`访问控制

4. 数据过滤

某些抓包工具（比如`Fiddler`、`Charles`）正是运用了代理服务器的原理。注意：`Wireshark`的原理是通过底层驱动，拦截网卡上流过的数据

<img src="网络协议.assets/image-20210221114817302.png" alt="image-20210221114817302" style="zoom:50%;" />



#### 5.1.2 反向代理

反向代理：代理的对象是服务器

<img src="网络协议.assets/image-20210221112214864.png" alt="image-20210221112214864" style="zoom:50%;" />

**作用**

1. 隐藏服务器身份

2. 安全防护

3. 负载均衡

   <img src="网络协议.assets/image-20210221113908920.png" alt="image-20210221113908920" style="zoom:50%;" />

#### 5.1.3 相关头部字段

![image-20210221115323441](网络协议.assets/image-20210221115323441.png)

- `Via`：追加经过的每一台代理服务器的主机名（或域名）
- `X-Forwarded-For`：追加请求方的`IP`地址
- `X-Real-IP`：客户端的真实`IP`地址

第一次请求

```yaml
Via: proxy1
X-Forwarded-For: 14.14.14.14
X-Real-IP: 14.14.14.14
```

第二次请求

```yaml
Via: proxy1, proxy2
X-Forwarded-For: 14.14.14.14, 220.11.11.11
X-Real-IP: 14.14.14.14
```

第三次请求

```yaml
Via: proxy2
```

第四次请求

```yaml
Via: proxy2, proxy1
```

### 5.2 CDN

`CDN(Content Delivery Network或Content Distribution Network)`，内容分发网络。利用最靠近每位用户的服务器，更快更可靠地将音乐、图片、视频等资源文件（一般是静态资源）传递给用户

![image-20210221122145172](网络协议.assets/image-20210221122145172.png)

`CDN`运营商在全国、乃至全球的各个大枢纽城市都建立了机房，部署了大量拥有提高存储带宽的节点，构建了一个跨运营商、跨地域的专用网络。内容所有者（服务的拥有者）向`CDN`运营商支付费用，`CDN`将其内容交付给最终用户

请求拥有`CDN`的服务器的流程

<img src="网络协议.assets/image-20210221124019680.png" alt="image-20210221124019680" style="zoom:50%;" />

### 5.3 WebService

`WebService`，`Web`服务，是一种跨编程语言和跨操作系统平台的远程调用技术标准

使用场景：天气预报，手机归属地查询、航班信息查询、物流信息查询等，比如天气预报，是气象局把自己的服务以`WebService`形式暴露出来，让第三方程序可以调用这些服务功能。

事实上，`WebService`完全可以用普通的`Web API`取代（比如`HTTP`+`JSON`）

`SOAP(Simple Object Access Protocol)`，简单对象访问协议，很多时候`SOAP`=`HTTP`+`XML`，`WebService`使用`SOAP`协议来封装传输数据

<img src="网络协议.assets/image-20210222163654103.png" alt="image-20210222163654103" style="zoom:50%;" />

`WSDL(Web Service Description Language)`，`Web`服务描述语言，一个`XML`文档，用以描述`WebService`接口的细节（比如参数，返回值等），一般在`WebService`的`URL`后面跟上`?wsdl`获取`WSDL`信息

### 5.4 HTTPDNS

`HTTPDNS`是基于`HTTP`协议向`DNS`服务器发送域名解析请求

替代了基于`DNS`协议向运营商`Local DNS`发起解析请求的传统方式，可以避免`Local DNS`造成的域名劫持和跨网访问问题，常用在移动互联网中（比如在`Android`、`IOS`开发中）

| 优势点 | xx云HTTPDNS | 运营商Local DNS |
| ------ | ----------- | --------------- |
| 高速   | 高速访问    | 访问缓慢        |
| 安全   | 防劫持      | 广告劫持        |
| 智能   | 精准调度    | 解析转发        |
| 可靠   | 负载均衡    | 异常故障        |

### 5.5 VPN

`VPN(Virtual Private Network)`，虚拟私人网络。它可以在公共网络上建立专用网络，进行加密通讯

<img src="网络协议.assets/image-20210222192517006.png" alt="image-20210222192517006" style="zoom:50%;" />

**VPN的作用**

- 提高上网的安全性

- 保护公司内部资料

- 隐藏上网者的身份

- 突破网站的地域限制

  有些网站针对不同地区的用户展示不同的内容

- 突破网络封锁

  因为有`GFW(Great Firewall of China)`的限制，有些网站在国内访问不了

**VPN与代理的区别**

- 软件

  `VPN`一般需要安装`VPN`客户端软件

  代理不需要安装额外的软件

- 安全性

  `VPN`默认会对数据进行加密

  代理默认不会对数据进行加密（数据最终是否加密取决于使用的协议本身）

- 费用

  一般情况下，`VPN`比代理贵

**实现原理**

隧道协议`Tunneling Protocol`

常见的隧道协议

- `PPTP(Point to Point Tunneling Protocol)`：点对点隧道协议
- `L2TP(Layer Two Tunneling Protocol)`：第二层隧道协议
- `IPsec(Internet Protocol Security)`：互联网安全协议
- `SSL VPN`如`OpenVPN`

### 5.6 网络爬虫

网络爬虫`Web Crawler`，也叫网络蜘蛛`Web Spider`。模拟人类使用浏览器操作页面的行为

`robots.txt`是存放于网站根目录下的文本文件，比如`https://www.bilibili.com/robots.txt`。

- 用来告诉爬虫：哪些内容是不应被爬取的，哪些是可以被爬取的
- 因为一些系统中的`URL`是大小写敏感的，所以`robots.txt`的文件名应统一为小写
- 它不是一个规范，而只是约定俗成的，所以并不能保证网站的隐私

### 5.7 HTTP缓存

通常会缓存的情况是：`GET`请求+静态资源（比如`HTML`、`CSS`、`JS`、图片等）

#### 5.7.1 响应头

`Pragma`：作用类似于`Cache-Control`，`HTTP/1.0`的产物

`Expires`：缓存的过期时间（`GMT`格式时间），`HTTP/1.0`的产物

`Cache-Control`：设置缓存策略

**响应头**

- `no-storage`：不缓存数据到本地
- `public`：允许用户、代理服务器缓存数据到本地
- `private`：只允许用户缓存数据到本地
- `max-age`：缓存的有效时间，单位秒
- `Last-Modified`：资源的最后一次修改时间
- `ETag`：资源的唯一标识（根据文件内容计算出来的摘要值）

优先级：`pragma` > `Cache-Control` > `Expires`

**请求头**

- `If-None-Match`

  如果上一次的响应头中有`ETag`，就会将`ETag`的值作为请求头的值

  如果服务器发现资源的最新摘要值跟`If-None-Match`不匹配，就会返回新的资源`200 OK`

  否则，就不会返回资源的具体数据`304 Not Modified`

- `If-Modified-Since`

  如果上一次的响应头中没有`ETag`，有`Last-Modified`，就会将`Last-Modified`的值作为请求头的值

  如果服务器发现资源的最后一次修改时间晚于`If-Modified-Since`，就会返回新的资源`200 OK`

  否则，就不会返回资源的具体数据`304 Not Modified`

`Last-Modified`的缺陷

- 只能精确到秒级别，如果资源在1秒内被修改了，客户端将无法获取最新的资源数据
- 如果某些资源被修改了（最后一次修改时间发生了变化），但是内容并没有任何变化，相同数据重复传输

`ETag`

- 只要资源的内容没变化，就不会重复传输资源数据‘
- 紫瑶资源的内容发生了变化，就会返回最新的资源给客户端

#### 5.7.2 缓存使用流程

<img src="网络协议.assets/image-20210223111745903.png" alt="image-20210223111745903" style="zoom:50%;" />

## 6. 网络安全

网络通信中面临的4中安全威胁

<img src="网络协议.assets/image-20210221125105086.png" alt="image-20210221125105086" style="zoom:50%;" />

- 截获：窃听通信内容
- 中断：中断网络通信
- 篡改：篡改通信内容
- 伪造：伪造通信内容

### 6.1 ARP欺骗

`ARP`欺骗`ARP spoofing`，又称`ARP`毒化`ARP poisoning`、`ARP`病毒、`ARP`攻击。

**ARP欺骗的效果**

1. 可以让攻击者获取局域网上的数据包甚至可以篡改数据包
2. 可以让网络上特定的主机之间无法正常通信
3. 让送至特定`IP`地址的流量被错误送到攻击者所取代的地方

**攻击的核心步骤**

假设主机`C`是攻击者，主机`A`、`B`是被攻击者。`C`只要收到过`A`、`B`发送的`ARP`请求，就会拥有`A`、`B`的`IP`、`MAC`地址，就可以进行欺骗活动

1. `C`发送一个`ARP`响应给`B`，把响应包里的源`IP`设为`A`的`IP`地址，源`MAC`设为`C`的`MAC`地址
2. `B`收到`ARP`响应后，更新它的`ARP`表，把`A`的`MAC`地址`IP_A, MAC_A`改为`IP_A, MAC_C`
3. 当`B`要发送数据包给`A`时，它根据`ARP`表来封装数据包的头部，把目标`MAC`地址改为`MAC_C`，而非`MAC_A`
4. 当交换机收到`B`发送给`A`的数据包时，根据此包的目标`MAC`地址`MAC_C`而把数据包转发给`C`
5. `C`收到数据包后，可以把它存起来以后再发送给`A`，达到窃听效果。`C`也可以篡改数据后才发送数据包给`A`

**防护**

1. 静态`ARP`

2. `DHCP Snooping`，网络设备可借由`DHCP`保留网络上各电脑的`MAC`地址，在伪造的`ARP`数据包发出时即可侦测到

3. 利用一些软件监听`ARP`的不正常变动

   ...

### 6.2 DoS、DDoS

`DoS`攻击（拒绝服务攻击，`Denial-of-Service attack`），使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问

`DDoS`攻击（分布式拒绝服务攻击，`Distributed Denial-of-Service attack`），黑客使用网络上两个或以上被攻陷的电脑作为"僵尸"向特定的目标发动`DoS`攻击

`DoS`攻击可以分为两大类

1. 带宽消耗型：`UDP`洪水攻击、`ICMP`洪水攻击
2. 资源消耗型：`SYN`洪水攻击、`LAND`攻击

**SYN洪水攻击**

攻击者发送一系列的`SYN`请求到目标，然后让目标因收不到`ACK`（第三次握手）而进行等待、消耗资源

攻击方法：跳过发送最后的`ACK`信息，修改源`IP`地址，让目标送`SYN-ACK`到伪造的`IP`地址，因此目标永不可能收到`ACK`

**LAND攻击**

`LAND`攻击（局域网拒绝服务攻击，`Local Area Network Denial attack`），通过持续发送相同相同源地址和目标地址的欺骗数据包，使目标试图与自己建立连接，消耗系统资源直至崩溃

**防御**

防御方式通常为：入侵检测、流量过滤和多重验证，堵塞网络带宽的流量将被过滤，而正常的流量可正常通过

防火墙

- 防火墙可以设置规则，例如允许或拒绝特定通讯协议，端口或`IP`地址
- 当工具从少数不正常的`IP`地址发出时，可以简单的使用拒绝规则阻止一切从攻击源`IP`发出的通讯
- 复杂攻击难以用简单规则来组织，例如80端口遭受攻击时不可能拒绝端口所有通信，因为同时会组织合法流量
- 防火墙可能处于网络架构中过后的位置，路由器可能在恶意流量达到防火墙前即被攻击影响

交换机：大多数交换机有一定的速度限制和访问控制能力

路由器：和交换机类似，路由器也有一定的速度限制和访问控制能力

黑洞引导：将所有受攻击计算机的通信全部发送至一个"黑洞"(空接口或不存在的计算机地址)或者有足够能力处理洪流的网络设备商，以免网络受到较大影响

流量清洗：当流量被送到`DDoS`防护清洗中心时，通过采用抗`DDoS`软件处理，将正常流量和恶意流量区分开来

### 6.3 DNS劫持

`DNS`劫持，又称为域名劫持。攻击者篡改了某个域名的解析结果，使得指向该域名的`IP`变成了另一个`IP`，导致对相应网址的访问被劫持到里一个不可到达的或者假冒的网址，从而实现非法窃取用户信息或者破坏正常网络服务的目的

为了防止出现`DNS`劫持的现象，可以考虑使用更靠谱的`DNS`服务器，比如：`114.114.114.114`

- 谷歌：`8.8.8.8`、`8.8.4.4`
- 微软：`4.2.2.1`、`4.2.2.2`
- 百度：`180.76.76.76`
- 阿里：`223.5.5.5`、`223.6.6.6`

`HTTP`劫持：对`HTTP`数据包进行拦截处理，比如插入`JS`代码

### 6.4 加密和解密

`HTTP`协议默认是采用明文传输的，因此会有很大的安全隐患，常见的提高安全性的方法是：对通信内容进行加密后，再进行传输

常见的加密方式：

- 不可逆：单向散列函数：`MD5`、`SHA`等

- 可逆

  对称加密：`DES`、`3DES`、`AES`等

  非对称加密：`RSA`等

- 其它

  混合密码系统

  数据签名

  证书

#### 6.4.1 单向散列函数

单向散列函数，可以根据消息内容计算出散列值。散列值的长度和消息的长度无关，无论消息是`1bit`、`10M`、`100G`，单向散列函数都会计算出固定长度的散列值。根据散列值无法推算出原数据。

单向散列函数，也称为消息摘要函数`message digest function`、哈希函数`hash function`。输出的散列值，也称为消息摘要`message digest`、指纹`fingerprint`

**常见的散列函数**

`MD4`、`MD5`：产生128bit的散列值，`MD`就是`message Digest`的缩写，目前已不安全（被枚举破解）

`SHA-1`：产生160bit的散列值，目前已经不安全

`SHA-2`：`SHA-256`、`SHA-384`、`SHA-512`，散列值的长度分别是256bit、384bit、512bit

`SHA-3`：全新的标准

#### 6.4.2 对称加密

![image-20210221165558662](网络协议.assets/image-20210221165558662.png)

对称加密`Symmetric Cryptography`，加密用的密钥和解密用的密钥是相同的

**常见的对称加密的算法**

1. `DES(Data Encryption Standard)`

   ![image-20210221170053778](网络协议.assets/image-20210221170053778.png)

   `DES`是一种将`64bit`明文加密成`64bit`密文的对称加密算法，密钥长度`56bit`

   规格上来说，密钥长度是`64bit`，但每隔`7bit`会设置一个用错误检查的`bit`，因此密钥长度实质上是`56bit`

   由于`DES`每次只能加密`64bit`的数据，遇到比较大的数据，需要对`DES`加密进行迭代

   目前已经可以在短时间内被破解，不建议使用

2. `3DES(Triple Data Encryption Algorithm)`

   ![image-20210221171054789](网络协议.assets/image-20210221171054789.png)

   `3DES`，将`DES`重复3次所得到的一种密码算法，也叫做3重`DES`。`3DES`并不是进行三次`DES`加密，而是加密`Encryption`->解密`Decryption`->加密`Encryption`的过程

   目前还被一些银行等机构使用，但处理速度不高，安全性逐渐暴露出问题

3. `AES(Advanced Encryption Standard)`

   取代`DES`成为新标准的一种对称加密算法，又称`Rijndael`加密算法

   `AES`的密钥长度有128、192、256bit三种

   目前`AES`，已经逐步取代`DES`、`3DES`，成为首选的对称加密算法

**密钥配送**

在使用对称加密时，首先要进行双方的密钥交换

密钥配送方法

- 事先共享密钥
- 密钥分配中心`Key Distribution Center`，简称`KDC`
- `Diffie-Hellman`密钥交换
- 非对称加密

#### 6.4.3 非对称加密

![image-20210221165719710](网络协议.assets/image-20210221165719710.png)

非对称加密`Asymmetric Cryptography`，加密用的密钥和解密用的密钥是不同的，分为加密密钥和解密密钥2种

<img src="网络协议.assets/image-20210221174105320.png" alt="image-20210221174105320" style="zoom:50%;" />

- 加密密钥：一般是公开的，因此该密钥称为公钥`public key`。非对称加密也被称为公钥密码`Public-key Cryptography`
- 解密密钥：由消息接受者自己保管，不能公开，因此也称为私钥`private key`
- 公钥和私钥是一一对应的
- 由公钥加密的密文，必须使用该公钥对应的私钥才能解密
- 由私钥加密的密文，必须使用该私钥对应的公钥才能解密

#### 6.4.4 混合密码系统

对称加密的缺点：不能很好的解决密钥配送的问题

非对称加密的缺点：加密解密速度比较慢

混合密码系统：可以解决上述问题

网络上的密码通信所用的`SSL/TLS`都运用了混合密码系统

**加密**

回话密钥`session key`

- 为本次通信随机生成的临时密钥
- 作为对称加密的密钥，用于加密消息，提高速度

**加密步骤**

1. 首先，消息发送者要拥有消息接受者的公钥
2. 生成回话密钥，作为对称加密的密钥，加密消息
3. 用消息接受者的公钥，加密回话密钥
4. 将前两步生成的加密结果，一并发给消息接受者

**解密过程**

1. 消息接受者用自己的私钥解密出会话密钥
2. 再用第一步解密出来的会话密钥，解密消息

#### 6.4.5 数字签名

```mermaid
graph LR
A --> |发消息|B
```

`A`发送的内容可能是被篡改的，或者有人伪装成`A`发消息，或者就是`A`发的，但它可以否认。`B`如何确定这段消息的真实性？

数字签名

- 生成签名，由消息的发送者完成，通过“签名密钥”生成。一般是通过消息发送者的私钥进行签名
- 验证签名，由消息的接受者完成，通过“验证密钥”验证

<img src="网络协议.assets/image-20210221190400208.png" alt="image-20210221190400208" style="zoom:50%;" />

#### 6.4.6 证书

密码学中的证书，全称叫公钥证书`Public-key Certificate, PKC`，并由认证机构`Certificate Authority, CA`施加数字签名

<img src="网络协议.assets/image-20210221200747358.png" alt="image-20210221200747358" style="zoom:50%;" />

各大`CA`的公钥，默认已经内置在浏览器和操作系统中

证书的注册和下载

<img src="网络协议.assets/image-20210221201605359.png" alt="image-20210221201605359" style="zoom:50%;" />

## 7. 其他协议

### 7.1 FTP、WebSocket

#### 7.1.1 WebSocket

HTTP请求的特点，通信只能由客户端发起。所以，早期很多网站为了实现推送技术，所用的技术都是轮询。即浏览器每隔一段时间去请求服务器，为了能更好的节省服务器资源和带宽，并且能够实时地进行通讯，`HTML5`规范中出现了`WebSocket`协议

<img src="网络协议.assets/image-20210222140226772.png" alt="image-20210222140226772" style="zoom:50%;" />

`WebSocket`是基于`TCP`的支持全双工通信的应用层协议，客户端，服务器都可以主动发消息给对方

`WebSocket`使用`80(ws://)`、`443(wss://)`端口，可以饶过大多数防火墙的限制

通信之前，`WebSocket`需要先建立连接

`WebSocket`需要借助`HTTP`协议来建立连接（也叫做握手，`Handshake`），需要由客户端主动发出握手请求

<img src="网络协议.assets/image-20210222153504868.png" alt="image-20210222153504868" style="zoom:50%;" />

- `Connection`必须设置`Upgrade`，表示客户端希望连接升级

- `Upgrade`必须设置`websocket`，表示希望升级到`WebSocket`协议

- `Sec-WebSocket-Version`表示支持的表示支持的`WebSocket`的版本

- `Sec-WebSocket-key`是客户端生成的随机字符串，服务器收到后会进行如下操作

  在`Sec-WebSocket-key`的后面加上一个固定的`GUID`值`258EAFA5-E914-47DA-95CA-C5AB0DC85B11`

  将上述结果进行`SHA-1`摘要计算，得到的结果进行`HexBase64`编码，这次的结果作为`Sec-WebSocket-Accept`响应头的值，返回给客户端

#### 7.1.2 FTP

`FTP(File Transport Protocol)`，文件传输协议，是基于`TCP`的应用层协议

<img src="网络协议.assets/image-20210222174820433.png" alt="image-20210222174820433" style="zoom:50%;" />

`FTP`的`URL`格式

```
ftp://[user[:password]]@host[:port]/url-path
```

`FTP`有2种连接模式：主动`Active`和被动`Passive`，不管是哪种模式，都需要客户端和服务器建立2个连接

不管是哪种模式，都需要客户端和服务器建立2个连接

- 控制连接：用于传输状态信息（命令，`cmd`）
- 数据连接：用于传输文件和目录信息（`data`）

**主动连接**

<img src="网络协议.assets/image-20210222175630341.png" alt="image-20210222175630341" style="zoom:50%;" />

1. 客户端打开一个随机的命令端口，端口号大于`1024`假设为`N`，同时连接到服务器的命令端口21

2. 客户端开始监听`N+1`数据端口，同时向服务器发送一个`Port`命令给服务器的命令端口21

   此命令告诉服务器，客户端正在监听的数据端口是`N+1`，并且已准备好从端口接收数据

3. 服务器打开20号数据端口，并且创建和客户端数据端口`N+1`的连接

**被动模式**

<img src="网络协议.assets/image-20210222181657411.png" alt="image-20210222181657411" style="zoom:50%;" />

1. 客户端通过两个随机端口与服务器建立连接

   命令端口`N`、数据端口`N+1`

2. 客户端的命令端口`N`用于连接服务器的命令端口21

3. 客户端通过命令端口`N`发送`PASV`命令给服务器的命令端口21

4. 服务器打开一个随机的数据端口`P`，并告知客户端该端口号P

5. 客户端数据端口`N+1`发起与服务器数据端口`P`的连接

### 7.2 邮件

**发邮件使用的协议**

`SMTP(Simple Mail Transfer Protocol)`，简单邮件传输协议，基于`TCP`，服务器默认使用25端口，`SSL/TLS`使用465端口

**收邮件的协议**

`POP(Post Office Protocol)`，邮局协议，基于`TCP`，服务器默认使用110端口，`SSL/TLS`使用995端口

`IMAP(Internet Message Access Protocol)`，因特网信息访问协议，基于`TCP`，服务器默认使用143端口，`SSL/TLS`使用993端口

**收发邮件的过程**

<img src="网络协议.assets/image-20210222182717258.png" alt="image-20210222182717258" style="zoom:50%;" />

**POP和IMAP**

<img src="网络协议.assets/image-20210222183017547.png" alt="image-20210222183017547" style="zoom:50%;" />![image-20210222183106456](网络协议.assets/image-20210222183106456.png)

<img src="网络协议.assets/image-20210222183017547.png" alt="image-20210222183017547" style="zoom:50%;" />![image-20210222183106456](网络协议.assets/image-20210222183106456.png)

`POP`的特点

- 客户端连接服务器时，将会从服务器下载所有邮件，可以设置下载完成之后，立即或一段时间后删除服务器邮件
- 客户端的操作（比如删除邮件，移动到文件夹）不会跟服务器同步
- 每个客户端都是独立的，都可以获得其自己的邮件副本

`IMAP`的特点

- 客户端连接服务器时，获取的是服务器上邮件的基本信息，并不会下载邮件，等打开邮件时，才会下载邮件
- 客户端的操作（比如删除邮件、移动到文件夹）会跟服务器同步
- 所有客户端始终会看到相同的文件夹

### 7.3 即时通信

即时通信`Instant Messaging`，简称`IM`，平时使用的`QQ`、微信，都属于典型的`IM`应用

常用的协议

**XMPP**

`XMPP(Extensible Messaging and Presence Protocol)`，可扩展消息与存在协议，前身是`Jabber`，基于`TCP`，默认端口是`5222`、`5269`

使用`XML`格式进行传输，体积较大

**MQTT**

`MQTT(Message Queuing Telemetry Transport)`，消息队列遥测传输，基于`TCP`，默认端口`1883`、`8883`(带SSL/TLS)

开销很小，以降低网络流量，信息冗余远小于`XMPP`，不是专门为`IM`设计的协议，很多功能需要自己实现

### 7.4 流媒体

流媒体`Streaming Media`，又叫流式媒体。是指将一连串的多媒体数据压缩后，经过互联网分段发送数据，在互联网上即时传输影音以供观赏的一种技术。此技术使得数据包得以像流水一样发送，不使用此技术，就必须使用提前现在整个媒体文件

**常见协议**

`RTP(Real-Time Transport Protocol)`，实时传输协议，基于`UDP`

`RTCP(Real-Time Transport Control Protocol)`，实时传输控制协议，基于`UDP`，使用`RTP`的下一个端口

`RTSP(Real-Time Streaming Protocol)`，实时流协议，基于`TCP`、`UDP`的554端口

`RTMP(Real-Time Messaging Protocol)`，实时消息传输协议，基于`TCP`，默认端口`1935`

`HLS(HTTP Live Streaming)`，基于`HTTP`的流媒体网络传输协议

